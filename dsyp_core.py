# -*- coding: utf-8 -*-
"""dsyp_core

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OSufpjjQg49PBzu0M4a8i0zCseso-2za
"""

#Block 0: Header + แนวคิด (ตัด side effect)

# -*- coding: utf-8 -*-
"""
dsyp_core.py

DSYP core layer: load templates + question bank, fill placeholders, guardrails.
No hardcoded API keys and NO side-effect prints.
"""

#Block 1: Imports + Optional Gemini (ไม่พังถ้าไม่ได้ติดตั้ง)

import json
import re
import sqlite3
from datetime import date, datetime
from typing import Any, Dict, Optional, Tuple

import pandas as pd

try:
    import google.generativeai as genai
except Exception:
    genai = None

#Block 2: Constants (regex placeholder + forbidden keywords)

PH_RE = re.compile(r":([a-zA-Z_][a-zA-Z0-9_]*)")

FORBIDDEN = re.compile(
    r"\b(INSERT|UPDATE|DELETE|MERGE|DROP|ALTER|TRUNCATE|CREATE|GRANT|REVOKE)\b",
    flags=re.IGNORECASE,
)

DEFAULT_LOGICAL_TO_PHYSICAL_TABLE = {
    "SALES_MASTER": "SALES_MASTER",
    "CREDIT_CONTRACT": "CREDIT_CONTRACT",
}

#Block 3: Helpers เล็ก ๆ (กัน None / string)

import pandas as pd

def _as_str(x: Any) -> str:
    try:
        if pd.isna(x):
            return ""
    except Exception:
        pass
    return "" if x is None else str(x)

#Block 4: Date helpers (คำนวณช่วงเดือนปัจจุบัน + เดือนก่อน)

def _month_range(today: date) -> Tuple[str, str]:
    start = date(today.year, today.month, 1)
    if today.month == 12:
        end = date(today.year + 1, 1, 1)
    else:
        end = date(today.year, today.month + 1, 1)
    return start.isoformat(), end.isoformat()

def _prev_period(cur_start: str, cur_end: str) -> Tuple[str, str]:
    s = datetime.fromisoformat(cur_start).date()
    if s.month == 1:
        ps = date(s.year - 1, 12, 1)
    else:
        ps = date(s.year, s.month - 1, 1)
    pe = s
    return ps.isoformat(), pe.isoformat()

#Block 5: Guardrails (อนุญาตแค่ SELECT/WITH)

def _strip_leading_comments(sql: str) -> str:
    s = (sql or "").lstrip()

    # remove leading -- line comments
    while s.startswith("--"):
        nl = s.find("\n")
        if nl == -1:
            return ""
        s = s[nl + 1 :].lstrip()

    # remove leading /* ... */ block comments (repeat if multiple blocks)
    while s.startswith("/*"):
        end = s.find("*/")
        if end == -1:
            return ""
        s = s[end + 2 :].lstrip()

        # after block, also skip any -- comments immediately following
        while s.startswith("--"):
            nl = s.find("\n")
            if nl == -1:
                return ""
            s = s[nl + 1 :].lstrip()

    return s


def validate_select_only(sql: str) -> None:
    s = _strip_leading_comments(sql)

    if not s:
        raise ValueError("Empty SQL")
    if FORBIDDEN.search(s):
        raise ValueError("Forbidden SQL keyword found (DDL/DML).")
    if not (s.upper().startswith("SELECT") or s.upper().startswith("WITH")):
        raise ValueError("Only SELECT/WITH statements are allowed.")

#Block 6: Placeholder validation (แก้จุดที่พังง่ายที่สุด)

def extract_placeholders(sql_template: str) -> set[str]:
    return set(PH_RE.findall(sql_template or ""))

def validate_placeholders(sql_template: str, params: Dict[str, Any]) -> None:
    missing = extract_placeholders(sql_template) - set(params.keys())
    if missing:
        raise ValueError(f"Missing placeholders: {sorted(missing)}")

#Block 7: Render template (แทนค่าจริง + validate อีกที)

def render_template(sql_template: str, params: Dict[str, Any]) -> str:
    validate_placeholders(sql_template, params)

    sql = sql_template
    for k, v in params.items():
        rep = _as_str(v)

        # auto-quote ISO dates for common date placeholders
        if k in {"cur_start", "cur_end", "prev_start", "prev_end"} and rep:
            # if not already quoted
            if not (rep.startswith("'") and rep.endswith("'")):
                rep = f"'{rep}'"

        # if filter_clause is blank, use safe default
        if k == "filter_clause" and (not rep.strip()):
            rep = "AND 1=1"

        sql = sql.replace(f":{k}", rep)

    validate_select_only(sql)
    return sql

#Block 8: ทำให้ล้อกับไฟล์ templates ของคุณ (template_sql)

def _pick_template_sql_column(templates_df: pd.DataFrame) -> str:
    for c in ["template_sql", "sql_template", "template", "sql"]:
        if c in templates_df.columns:
            return c
    raise ValueError("No SQL template column found (expected template_sql/sql_template/...)")

#Block 9: ✅ FIX ตัวสำคัญที่หายไป (ทำให้ไม่ NameError)

def _get_template_row(templates_df: pd.DataFrame, key: str) -> pd.Series:
    m = templates_df[templates_df["sql_template_key"] == key]
    if m.empty:
        raise KeyError(f"Template key not found: {key}")
    return m.iloc[0]

def _get_qb_row_for_key(question_bank_df: pd.DataFrame, key: str) -> pd.Series:
    m = question_bank_df[question_bank_df["sql_template_key"] == key]
    if m.empty:
        raise KeyError(f"Question bank row not found for key: {key}")
    return m.iloc[0]

#Block 10: build_params_for_template (หัวใจการ “ล้อกับ question_bank”)

def build_params_for_template(
    router_out: Dict[str, Any],
    question_bank_df: pd.DataFrame,
    templates_df: pd.DataFrame,
    logical_to_physical_table: Optional[Dict[str, str]] = None,
    today: Optional[date] = None,
) -> Tuple[str, Dict[str, Any]]:
    if logical_to_physical_table is None:
        logical_to_physical_table = dict(DEFAULT_LOGICAL_TO_PHYSICAL_TABLE)
    if today is None:
        today = date.today()

    key = router_out["sql_template_key"]

    tpl_row = _get_template_row(templates_df, key)
    tpl_col = _pick_template_sql_column(templates_df)
    sql_template = str(tpl_row[tpl_col])

    qb_row = _get_qb_row_for_key(question_bank_df, key)

    cur_start, cur_end = _month_range(today)
    prev_start, prev_end = _prev_period(cur_start, cur_end)

    params = {
        "table_name": logical_to_physical_table.get(str(qb_row.get("main_table", "")).strip(), None),
        "date_field": qb_row.get("date_field", None),
        "metric_expr": qb_row.get("metric_expression", None),
        "dimension": qb_row.get("dimension", None),
        "top_n": qb_row.get("top_n", 10),
        "filter_clause": qb_row.get("filter_hint", "AND 1=1"),
        "cur_start": cur_start,
        "cur_end": cur_end,
        "prev_start": prev_start,
        "prev_end": prev_end,
        # ✅ add these
        "dim_field": qb_row.get("dimension", None),
        "group_by_field": qb_row.get("dimension", None),
    }

    sql = render_template(sql_template, params)
    return sql, params

# =========================
# Block 11: Gemini LLM (Router)
# =========================

def gemini_generate_text(prompt: str, model_name: str = "gemini-2.0-flash") -> str:
    """
    Generate text from Gemini using google-generativeai.
    IMPORTANT:
      - Do NOT put API key in this file.
      - Configure in runtime (notebook/streamlit) before calling:
          import google.generativeai as genai
          genai.configure(api_key=...)
    """
    if genai is None:
        raise RuntimeError(
            "google.generativeai is not available. Install it first:\n"
            "  pip install -U google-generativeai\n"
            "and configure API key in runtime before calling LLM functions."
        )

    model = genai.GenerativeModel(model_name)
    resp = model.generate_content(prompt)

    text = getattr(resp, "text", None)
    if not text or not str(text).strip():
        raise RuntimeError("Gemini returned empty text (possibly blocked or empty response).")
    return str(text).strip()


def call_router_llm(
    user_question: str,
    question_bank_df: pd.DataFrame,
    schema_doc: str,
    model_name: str = "gemini-2.0-flash",
) -> Dict[str, Any]:
    """
    Route a natural-language question to sql_template_key.
    Returns dict like: {"sql_template_key": "..."} (may include extra fields).
    """
    # Keep QB compact but informative
    qb_cols = [c for c in [
        "sql_template_key", "question_text_th", "question_text_en",
        "intent_type", "main_table", "metric_expression", "date_field",
        "dimension", "compare_type", "multi_dim_flag", "filter_hint", "top_n"
    ] if c in question_bank_df.columns]

    qb_view = question_bank_df[qb_cols].copy() if qb_cols else question_bank_df.copy()
    qb_text = qb_view.to_string(index=False)

    prompt = f"""
You are a SQL template router. Choose the best sql_template_key from QUESTION_BANK.
Return STRICT JSON only (no markdown, no extra text).

USER_QUESTION:
{user_question}

QUESTION_BANK:
{qb_text}

SCHEMA_DOC:
{schema_doc}

Rules:
- Output MUST be valid JSON only.
- MUST include: "sql_template_key"
- Choose exactly one best key.
"""

    txt = gemini_generate_text(prompt, model_name=model_name)

    # If model accidentally wraps in ```json ... ```, strip it
    if txt.startswith("```"):
        txt = txt.strip().strip("`").strip()
        if txt.lower().startswith("json"):
            txt = txt[4:].strip()

    try:
        out = json.loads(txt)
    except Exception as e:
        raise ValueError(f"Router output is not valid JSON. Raw text:\n{txt}") from e

    if not isinstance(out, dict):
        raise ValueError(f"Router JSON must be an object/dict. Got: {type(out)}")

    if "sql_template_key" not in out or not str(out["sql_template_key"]).strip():
        raise ValueError(f"Router output missing sql_template_key. Got: {out}")

    # normalize
    out["sql_template_key"] = str(out["sql_template_key"]).strip()
    return out
